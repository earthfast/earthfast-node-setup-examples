name: Content Node Test
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  deploy-and-test:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Create EC2 instance
        id: ec2
        run: |
          # Get existing security group ID
          SG_ID=$(aws ec2 describe-security-groups \
            --group-names content-node-test \
            --query 'SecurityGroups[0].GroupId' \
            --output text)
  
          # Verify security group rules
          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 22 \
            --cidr 0.0.0.0/0 || true  # Don't fail if rule exists
  
          # Create EC2 instance
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ami-0c7217cdde317cfec \
            --instance-type t2.medium \
            --security-group-ids $SG_ID \
            --key-name ${{ secrets.AWS_KEY_NAME }} \
            --output text \
            --query 'Instances[0].InstanceId')
  
          echo "Waiting for instance to be running..."
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
  
          # Get public IP
          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
  
          # Wait for instance status checks
          echo "Waiting for instance status checks..."
          aws ec2 wait instance-status-ok --instance-ids $INSTANCE_ID
  
          echo "instance_id=${INSTANCE_ID}" >> "$GITHUB_OUTPUT"
          echo "public_ip=${PUBLIC_IP}" >> "$GITHUB_OUTPUT"
    
      - name: Deploy and configure content node
        env:
          PRIVATE_KEY: ${{ secrets.AWS_SSH_PRIVATE_KEY }}
          PUBLIC_IP: ${{ steps.ec2.outputs.public_ip }}
          BRANCH: ${{ github.head_ref || github.ref_name }}
        run: |
          if [ -z "$PUBLIC_IP" ]; then
            echo "Error: PUBLIC_IP is empty"
            exit 1
          fi
  
          echo "Using Public IP: ${PUBLIC_IP}"
          
          # Save private key with proper OpenSSH format
          umask 077
          echo "$PRIVATE_KEY" > private_key.pem
          
          # Wait longer for instance to be ready
          echo "Waiting for SSH to be available..."
          for i in {1..30}; do
            if ssh -q -i private_key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=5 ubuntu@${PUBLIC_IP} exit; then
              echo "SSH connection successful"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "Timeout waiting for SSH"
              exit 1
            fi
            echo "Attempt $i: Waiting for SSH to be available..."
            sleep 10
          done
  
          # First SSH session - setup
          ssh -tt -i private_key.pem -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP} << EOF
          git clone -b ${BRANCH} https://github.com/earthfast/earthfast-node-setup-examples.git
          cd earthfast-node-setup-examples/content-node/docker-compose
          ./setup.sh << ENDSETUP
          ${PUBLIC_IP}
          0x1234567890123456789012345678901234567890123456789012345678901234
          false
          test@earthfast.com
          ENDSETUP
          EOF
            
          # Second SSH session - start services after logging out/in
          ssh -tt -i private_key.pem -o StrictHostKeyChecking=no ec2-user@${PUBLIC_IP} << 'EOF'
          cd earthfast-node-setup-examples/content-node/docker-compose
          docker compose up -d
          EOF

      - name: Test /statusz endpoint
        run: |
          # Wait for service to be ready
          sleep 30

          for i in {1..6}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" http://${{ steps.ec2.outputs.public_ip }}/statusz)
            if [ "$response" = "200" ]; then
              echo "Statusz check passed"
              exit 0
            fi
            echo "Attempt $i: Status code $response, waiting 10 seconds..."
            sleep 10
          done
          echo "Statusz check failed after all attempts"
          exit 1

      - name: Cleanup
        if: always()
        env:
          INSTANCE_ID: ${{ steps.ec2.outputs.instance_id }}
        run: |
          if [ -z "$INSTANCE_ID" ]; then
            echo "Error: INSTANCE_ID is empty"
            exit 1
          fi

          echo "Terminating instance: ${INSTANCE_ID}"
          aws ec2 terminate-instances --instance-ids ${INSTANCE_ID}
          aws ec2 wait instance-terminated --instance-ids ${INSTANCE_ID}
