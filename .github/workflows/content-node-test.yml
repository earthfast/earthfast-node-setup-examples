name: Content Node Test
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  deploy-and-test:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Create EC2 instance
        id: ec2
        run: |
          # Get existing security group ID
          SG_ID=$(aws ec2 describe-security-groups \
            --group-names content-node-test \
            --query 'SecurityGroups[0].GroupId' \
            --output text)

          echo "Security Group ID: $SG_ID"  # Debug output

          # Create EC2 instance
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ami-0c7217cdde317cfec \
            --instance-type t2.medium \
            --security-group-ids $SG_ID \
            --key-name ${{ secrets.AWS_KEY_NAME }} \
            --output text \
            --query 'Instances[0].InstanceId')

          echo "Instance ID: $INSTANCE_ID"  # Debug output

          # Wait for instance to be running
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID

          # Get public IP
          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)

          echo "Public IP: $PUBLIC_IP"  # Debug output

          # Set outputs with explicit echo statements
          echo "instance_id=${INSTANCE_ID}" >> "$GITHUB_OUTPUT"
          echo "public_ip=${PUBLIC_IP}" >> "$GITHUB_OUTPUT"

          # Verify outputs were set
          cat "$GITHUB_OUTPUT"

      - name: Debug Outputs # Add this step for debugging
        run: |
          echo "Instance ID: ${{ steps.ec2.outputs.instance_id }}"
          echo "Public IP: ${{ steps.ec2.outputs.public_ip }}"

      - name: Deploy and configure content node
        env:
          PRIVATE_KEY: ${{ secrets.AWS_SSH_PRIVATE_KEY }}
          PUBLIC_IP: ${{ steps.ec2.outputs.public_ip }}
          BRANCH: ${{ github.head_ref || github.ref_name }}
        run: |
          if [ -z "$PUBLIC_IP" ]; then
            echo "Error: PUBLIC_IP is empty"
            exit 1
          fi

          echo "Using Public IP: ${PUBLIC_IP}"
          
          # Save private key with proper OpenSSH format
          umask 077
          echo "$PRIVATE_KEY" > private_key.pem
          
          # Debug key format and permissions
          ls -l private_key.pem
          head -n 1 private_key.pem
          
          # Debug SSH connection
          ssh -v -i private_key.pem -o StrictHostKeyChecking=no ubuntu@${PUBLIC_IP} echo "SSH test"
          
          # Wait for instance to be ready
          sleep 30

          # First SSH session - setup
          ssh -tt -i private_key.pem -o StrictHostKeyChecking=no ec2-user@${PUBLIC_IP} << EOF
          git clone -b ${BRANCH} https://github.com/earthfast/earthfast-node-setup-examples.git
          cd earthfast-node-setup-examples/content-node/docker-compose
          ./setup.sh << ENDSETUP
          ${PUBLIC_IP}
          0x1234567890123456789012345678901234567890123456789012345678901234
          false
          test@earthfast.com
          ENDSETUP
          EOF
            
          # Second SSH session - start services after logging out/in
          ssh -tt -i private_key.pem -o StrictHostKeyChecking=no ec2-user@${PUBLIC_IP} << 'EOF'
          cd earthfast-node-setup-examples/content-node/docker-compose
          docker compose up -d
          EOF

      - name: Test /statusz endpoint
        run: |
          # Wait for service to be ready
          sleep 30

          for i in {1..6}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" http://${{ steps.ec2.outputs.public_ip }}/statusz)
            if [ "$response" = "200" ]; then
              echo "Statusz check passed"
              exit 0
            fi
            echo "Attempt $i: Status code $response, waiting 10 seconds..."
            sleep 10
          done
          echo "Statusz check failed after all attempts"
          exit 1

      - name: Cleanup
        if: always()
        env:
          INSTANCE_ID: ${{ steps.ec2.outputs.instance_id }}
        run: |
          if [ -z "$INSTANCE_ID" ]; then
            echo "Error: INSTANCE_ID is empty"
            exit 1
          fi

          echo "Terminating instance: ${INSTANCE_ID}"
          aws ec2 terminate-instances --instance-ids ${INSTANCE_ID}
          aws ec2 wait instance-terminated --instance-ids ${INSTANCE_ID}
